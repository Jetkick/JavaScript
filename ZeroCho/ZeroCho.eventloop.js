
// 코드 실행 => 호출 스택 => 백그라운드 => 태스크 큐 => 스택 && 이벤트 루프 => 태스크 큐 => 스택

// 호출 스택은 동기 코드를 담당하고, 이벤트 루프는 비동기 코드를 담당한다고 생각하면 됩니다. 추가로
// 비동기 코드 실행에는 백그라운드 태스크 큐라는 개념도 등장합니다. 태스크 큐는 다시 세분화해서 나뉠 수 있습니다.

// 호출 스택 : 함수들이 실행되는 곳

// 백그라운드 : 이벤트 리스너와 타이머가 들어가는 공간
/* 백그라운드는 타이머를 처리하고 이벤트 리스너를 저장하는 공간입니다. setTimeout 같은 함수가
실행되면 백그라운드에서 시간이 흘러가고 시간이 다 되면 setTimeout 의 콜백 함수를 태스크 큐로 보냅니다.
또한, addEventListener 로 추가한 이벤트를 저장했다가 이벤트가 발생하면 콜백 함수를 태스크 큐로 보냅니다.
 백그라운드에서 코드를 실행하는 것이 아니라 실행될 콜백 함수들이 태스크 큐로 들어간다는 것을 기억하세요.*/

// 태스크 큐 :  이벤트 리스너와 타이머에 들어가 있는 콜백함수가 들어있는 공간
/* 태스크 큐는 실행되야 할 콜백 함수들이 줄을 서서 대기하고 있는 공간입니다. queue 라는 단어가 줄이라는 뜻입니다.
사람들이 가게 앞에 줄을 서면 먼저 선 사람부터 차례로 들어가죠? 태스크 큐도 마찬가지입니다. 태스크 큐에 먼저 들어온 함수부터
실행됩니다. 다만, 태스크 큐도 함수를 직접 실행하지 않습니다. 함수는 모두 호출 스택에서만 실행됩니다.
호출 스택에 들어온 함수가 호출(실행)된다고 생각하면 됩니다. */

// 이벤트 루프 : 호출 스택이 비어 있을때 태스크 큐에 있는 콜백함수를 하나씩 꺼내주는 역할
/* 태스크 큐에서 호출 스택으로 함수를 이동시키는 존재가 바로 이벤트 루프입니다. 호출 스택이 비어 있으면 이벤트 루프는
태스크 큐에서 함수를 하나씩 꺼내(들어온 순서로 꺼낸다) 호출스택으로 옮깁니다. 호출 스택으로 이동한 함수는 그제서야 실행됩니다.
실행이 완료된 함수는 호출 스택에서 빠져나가게 되고, 호출 스택이 비면 이벤트 루프는 태스크 큐에 있는 다음 함수를 호출 스택으로 옮깁니다. */


 // script tag 안에 코드가 들어가있다. 
 // JavaScript 함수를 실행한다는 것은 function anonymous 함수를  실행한다는 것과 같다.

function a() {
  b();
}

function b() {
  console.trace();  // trace : 호출 스택에 쌓이는 함수의 순서를 보여줌
}

a();
// </코드> a 함수가 실행되고, 그 안에서 b 함수가 실행됩니다. 그리고 b 함수 안에서 console.trace 메서드가 실행됩니다. console.trace 는 함수의 호출 스택을 보여주는 메서드입니다.
// </어노니머스> 
// anonymous 함수 실행 => 함수 a 호출 => 함수 a 안에 있는 함수 b 실행 => 함수 b 안에 있는 console.trace() 을 실행. => b 종료 => a 종료 => anonymous 종료 => return 값 없음 undefined 출력
// 그래서 쌓이는건 아래에서 부터 쌓이고 - 코드 관점 - 종료는 위에서 부터 종료가 된다 - 어노니머스 관점 - 
// anonymous 함수가 호출 스택으로 보내주기 때문에 anonymous 함수가 실행된다.???

// JavaScript는 이벤트 루프를 통해 비동기 언어를 지원하는 것이다.


// 이벤트 루프 분석

function aaa() {
  setTimeout(() => {
    console.log('d');
  }, 0);
  console.log('c');
}

setTimeout(() => {
  console.log('a');
  aaa();
}, 0);

setTimeout(() => {
  aaa();
  console.log('b');
}, 0);

// Src = "https://docs.google.com/spreadsheets/d/1jauf6x_3CvitB0gNtBoZ3-Nj1wRhKzyNYuXkZZyldUg/edit#gid=0"